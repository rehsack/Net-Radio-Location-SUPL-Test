# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.6
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package SUPL::XS;
use base qw(Exporter);
use base qw(DynaLoader);
package SUPL::XSc;
bootstrap SUPL::XS;
package SUPL::XS;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package SUPL::XS;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package SUPL::XS;

*encode_ulp_pdu = *SUPL::XSc::encode_ulp_pdu;
*decode_ulp_pdu = *SUPL::XSc::decode_ulp_pdu;
*ulp_pdu_to_xml = *SUPL::XSc::ulp_pdu_to_xml;
*dump_ulp_pdu = *SUPL::XSc::dump_ulp_pdu;

############# Class : SUPL::XS::SUPLAUTHREQ_t ##############

package SUPL::XS::SUPLAUTHREQ_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SUPL::XS );
%OWNER = ();
%ITERATORS = ();
*swig_sETNonce_get = *SUPL::XSc::SUPLAUTHREQ_t_sETNonce_get;
*swig_sETNonce_set = *SUPL::XSc::SUPLAUTHREQ_t_sETNonce_set;
*swig_keyIdentity2_get = *SUPL::XSc::SUPLAUTHREQ_t_keyIdentity2_get;
*swig_keyIdentity2_set = *SUPL::XSc::SUPLAUTHREQ_t_keyIdentity2_set;
*swig__asn_ctx_get = *SUPL::XSc::SUPLAUTHREQ_t__asn_ctx_get;
*swig__asn_ctx_set = *SUPL::XSc::SUPLAUTHREQ_t__asn_ctx_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SUPL::XSc::delete_SUPLAUTHREQ_t($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = SUPL::XSc::new_SUPLAUTHREQ_t(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SUPL::XS::SUPLAUTHRESP_t ##############

package SUPL::XS::SUPLAUTHRESP_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SUPL::XS );
%OWNER = ();
%ITERATORS = ();
*swig_sPCAuthKey_get = *SUPL::XSc::SUPLAUTHRESP_t_sPCAuthKey_get;
*swig_sPCAuthKey_set = *SUPL::XSc::SUPLAUTHRESP_t_sPCAuthKey_set;
*swig_keyIdentity3_get = *SUPL::XSc::SUPLAUTHRESP_t_keyIdentity3_get;
*swig_keyIdentity3_set = *SUPL::XSc::SUPLAUTHRESP_t_keyIdentity3_set;
*swig_statusCode_get = *SUPL::XSc::SUPLAUTHRESP_t_statusCode_get;
*swig_statusCode_set = *SUPL::XSc::SUPLAUTHRESP_t_statusCode_set;
*swig__asn_ctx_get = *SUPL::XSc::SUPLAUTHRESP_t__asn_ctx_get;
*swig__asn_ctx_set = *SUPL::XSc::SUPLAUTHRESP_t__asn_ctx_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SUPL::XSc::delete_SUPLAUTHRESP_t($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = SUPL::XSc::new_SUPLAUTHRESP_t(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SUPL::XS::SUPLEND_t ##############

package SUPL::XS::SUPLEND_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SUPL::XS );
%OWNER = ();
%ITERATORS = ();
*swig_position_get = *SUPL::XSc::SUPLEND_t_position_get;
*swig_position_set = *SUPL::XSc::SUPLEND_t_position_set;
*swig_statusCode_get = *SUPL::XSc::SUPLEND_t_statusCode_get;
*swig_statusCode_set = *SUPL::XSc::SUPLEND_t_statusCode_set;
*swig_ver_get = *SUPL::XSc::SUPLEND_t_ver_get;
*swig_ver_set = *SUPL::XSc::SUPLEND_t_ver_set;
*swig__asn_ctx_get = *SUPL::XSc::SUPLEND_t__asn_ctx_get;
*swig__asn_ctx_set = *SUPL::XSc::SUPLEND_t__asn_ctx_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SUPL::XSc::delete_SUPLEND_t($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = SUPL::XSc::new_SUPLEND_t(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SUPL::XS::SUPLINIT_t ##############

package SUPL::XS::SUPLINIT_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SUPL::XS );
%OWNER = ();
%ITERATORS = ();
*swig_posMethod_get = *SUPL::XSc::SUPLINIT_t_posMethod_get;
*swig_posMethod_set = *SUPL::XSc::SUPLINIT_t_posMethod_set;
*swig_notification_get = *SUPL::XSc::SUPLINIT_t_notification_get;
*swig_notification_set = *SUPL::XSc::SUPLINIT_t_notification_set;
*swig_sLPAddress_get = *SUPL::XSc::SUPLINIT_t_sLPAddress_get;
*swig_sLPAddress_set = *SUPL::XSc::SUPLINIT_t_sLPAddress_set;
*swig_qoP_get = *SUPL::XSc::SUPLINIT_t_qoP_get;
*swig_qoP_set = *SUPL::XSc::SUPLINIT_t_qoP_set;
*swig_sLPMode_get = *SUPL::XSc::SUPLINIT_t_sLPMode_get;
*swig_sLPMode_set = *SUPL::XSc::SUPLINIT_t_sLPMode_set;
*swig_mAC_get = *SUPL::XSc::SUPLINIT_t_mAC_get;
*swig_mAC_set = *SUPL::XSc::SUPLINIT_t_mAC_set;
*swig_keyIdentity_get = *SUPL::XSc::SUPLINIT_t_keyIdentity_get;
*swig_keyIdentity_set = *SUPL::XSc::SUPLINIT_t_keyIdentity_set;
*swig__asn_ctx_get = *SUPL::XSc::SUPLINIT_t__asn_ctx_get;
*swig__asn_ctx_set = *SUPL::XSc::SUPLINIT_t__asn_ctx_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SUPL::XSc::delete_SUPLINIT_t($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = SUPL::XSc::new_SUPLINIT_t(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SUPL::XS::SUPLPOS_t ##############

package SUPL::XS::SUPLPOS_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SUPL::XS );
%OWNER = ();
%ITERATORS = ();
*swig_posPayLoad_get = *SUPL::XSc::SUPLPOS_t_posPayLoad_get;
*swig_posPayLoad_set = *SUPL::XSc::SUPLPOS_t_posPayLoad_set;
*swig_velocity_get = *SUPL::XSc::SUPLPOS_t_velocity_get;
*swig_velocity_set = *SUPL::XSc::SUPLPOS_t_velocity_set;
*swig__asn_ctx_get = *SUPL::XSc::SUPLPOS_t__asn_ctx_get;
*swig__asn_ctx_set = *SUPL::XSc::SUPLPOS_t__asn_ctx_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SUPL::XSc::delete_SUPLPOS_t($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = SUPL::XSc::new_SUPLPOS_t(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SUPL::XS::SUPLPOSINIT_t ##############

package SUPL::XS::SUPLPOSINIT_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SUPL::XS );
%OWNER = ();
%ITERATORS = ();
*swig_sETCapabilities_get = *SUPL::XSc::SUPLPOSINIT_t_sETCapabilities_get;
*swig_sETCapabilities_set = *SUPL::XSc::SUPLPOSINIT_t_sETCapabilities_set;
*swig_requestedAssistData_get = *SUPL::XSc::SUPLPOSINIT_t_requestedAssistData_get;
*swig_requestedAssistData_set = *SUPL::XSc::SUPLPOSINIT_t_requestedAssistData_set;
*swig_locationId_get = *SUPL::XSc::SUPLPOSINIT_t_locationId_get;
*swig_locationId_set = *SUPL::XSc::SUPLPOSINIT_t_locationId_set;
*swig_position_get = *SUPL::XSc::SUPLPOSINIT_t_position_get;
*swig_position_set = *SUPL::XSc::SUPLPOSINIT_t_position_set;
*swig_sUPLPOS_get = *SUPL::XSc::SUPLPOSINIT_t_sUPLPOS_get;
*swig_sUPLPOS_set = *SUPL::XSc::SUPLPOSINIT_t_sUPLPOS_set;
*swig_ver_get = *SUPL::XSc::SUPLPOSINIT_t_ver_get;
*swig_ver_set = *SUPL::XSc::SUPLPOSINIT_t_ver_set;
*swig__asn_ctx_get = *SUPL::XSc::SUPLPOSINIT_t__asn_ctx_get;
*swig__asn_ctx_set = *SUPL::XSc::SUPLPOSINIT_t__asn_ctx_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SUPL::XSc::delete_SUPLPOSINIT_t($self);
        delete $OWNER{$self};
    }
}

*set_capabilities = *SUPL::XSc::SUPLPOSINIT_t_set_capabilities;
*set_requested_assist_data = *SUPL::XSc::SUPLPOSINIT_t_set_requested_assist_data;
*update_requested_assist_data = *SUPL::XSc::SUPLPOSINIT_t_update_requested_assist_data;
*SUPLPOSINIT_set_requested_assist_navigation_modell = *SUPL::XSc::SUPLPOSINIT_t_SUPLPOSINIT_set_requested_assist_navigation_modell;
sub new {
    my $pkg = shift;
    my $self = SUPL::XSc::new_SUPLPOSINIT_t(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SUPL::XS::SUPLRESPONSE_t ##############

package SUPL::XS::SUPLRESPONSE_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SUPL::XS );
%OWNER = ();
%ITERATORS = ();
*swig_posMethod_get = *SUPL::XSc::SUPLRESPONSE_t_posMethod_get;
*swig_posMethod_set = *SUPL::XSc::SUPLRESPONSE_t_posMethod_set;
*swig_sLPAddress_get = *SUPL::XSc::SUPLRESPONSE_t_sLPAddress_get;
*swig_sLPAddress_set = *SUPL::XSc::SUPLRESPONSE_t_sLPAddress_set;
*swig_sETAuthKey_get = *SUPL::XSc::SUPLRESPONSE_t_sETAuthKey_get;
*swig_sETAuthKey_set = *SUPL::XSc::SUPLRESPONSE_t_sETAuthKey_set;
*swig_keyIdentity4_get = *SUPL::XSc::SUPLRESPONSE_t_keyIdentity4_get;
*swig_keyIdentity4_set = *SUPL::XSc::SUPLRESPONSE_t_keyIdentity4_set;
*swig__asn_ctx_get = *SUPL::XSc::SUPLRESPONSE_t__asn_ctx_get;
*swig__asn_ctx_set = *SUPL::XSc::SUPLRESPONSE_t__asn_ctx_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SUPL::XSc::delete_SUPLRESPONSE_t($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = SUPL::XSc::new_SUPLRESPONSE_t(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SUPL::XS::SUPLSTART_t ##############

package SUPL::XS::SUPLSTART_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SUPL::XS );
%OWNER = ();
%ITERATORS = ();
*swig_sETCapabilities_get = *SUPL::XSc::SUPLSTART_t_sETCapabilities_get;
*swig_sETCapabilities_set = *SUPL::XSc::SUPLSTART_t_sETCapabilities_set;
*swig_locationId_get = *SUPL::XSc::SUPLSTART_t_locationId_get;
*swig_locationId_set = *SUPL::XSc::SUPLSTART_t_locationId_set;
*swig_qoP_get = *SUPL::XSc::SUPLSTART_t_qoP_get;
*swig_qoP_set = *SUPL::XSc::SUPLSTART_t_qoP_set;
*swig__asn_ctx_get = *SUPL::XSc::SUPLSTART_t__asn_ctx_get;
*swig__asn_ctx_set = *SUPL::XSc::SUPLSTART_t__asn_ctx_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SUPL::XSc::delete_SUPLSTART_t($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = SUPL::XSc::new_SUPLSTART_t(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SUPL::XS::ULP_PDU_t ##############

package SUPL::XS::ULP_PDU_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SUPL::XS );
%OWNER = ();
%ITERATORS = ();
*swig_length_get = *SUPL::XSc::ULP_PDU_t_length_get;
*swig_length_set = *SUPL::XSc::ULP_PDU_t_length_set;
*swig_version_get = *SUPL::XSc::ULP_PDU_t_version_get;
*swig_version_set = *SUPL::XSc::ULP_PDU_t_version_set;
*swig_sessionID_get = *SUPL::XSc::ULP_PDU_t_sessionID_get;
*swig_sessionID_set = *SUPL::XSc::ULP_PDU_t_sessionID_set;
*swig_message_get = *SUPL::XSc::ULP_PDU_t_message_get;
*swig_message_set = *SUPL::XSc::ULP_PDU_t_message_set;
*swig__asn_ctx_get = *SUPL::XSc::ULP_PDU_t__asn_ctx_get;
*swig__asn_ctx_set = *SUPL::XSc::ULP_PDU_t__asn_ctx_set;
sub new {
    my $pkg = shift;
    my $self = SUPL::XSc::new_ULP_PDU_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SUPL::XSc::delete_ULP_PDU_t($self);
        delete $OWNER{$self};
    }
}

*set_version = *SUPL::XSc::ULP_PDU_t_set_version;
*setSetSessionId_to_imsi = *SUPL::XSc::ULP_PDU_t_setSetSessionId_to_imsi;
*setSetSessionId_to_msisdn = *SUPL::XSc::ULP_PDU_t_setSetSessionId_to_msisdn;
*copy_SlpSessionId = *SUPL::XSc::ULP_PDU_t_copy_SlpSessionId;
*set_message_type = *SUPL::XSc::ULP_PDU_t_set_message_type;
*dump = *SUPL::XSc::ULP_PDU_t_dump;
*xml_dump = *SUPL::XSc::ULP_PDU_t_xml_dump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SUPL::XS::UlpMessage_t ##############

package SUPL::XS::UlpMessage_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SUPL::XS );
%OWNER = ();
%ITERATORS = ();
*swig_present_get = *SUPL::XSc::UlpMessage_t_present_get;
*swig_present_set = *SUPL::XSc::UlpMessage_t_present_set;
*swig__asn_ctx_get = *SUPL::XSc::UlpMessage_t__asn_ctx_get;
*swig__asn_ctx_set = *SUPL::XSc::UlpMessage_t__asn_ctx_set;
*swig_choice_get = *SUPL::XSc::UlpMessage_t_choice_get;
*swig_choice_set = *SUPL::XSc::UlpMessage_t_choice_set;
sub new {
    my $pkg = shift;
    my $self = SUPL::XSc::new_UlpMessage_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SUPL::XSc::delete_UlpMessage_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SUPL::XS::UlpMessage_t_choice ##############

package SUPL::XS::UlpMessage_t_choice;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SUPL::XS );
%OWNER = ();
%ITERATORS = ();
*swig_msSUPLINIT_get = *SUPL::XSc::UlpMessage_t_choice_msSUPLINIT_get;
*swig_msSUPLINIT_set = *SUPL::XSc::UlpMessage_t_choice_msSUPLINIT_set;
*swig_msSUPLSTART_get = *SUPL::XSc::UlpMessage_t_choice_msSUPLSTART_get;
*swig_msSUPLSTART_set = *SUPL::XSc::UlpMessage_t_choice_msSUPLSTART_set;
*swig_msSUPLRESPONSE_get = *SUPL::XSc::UlpMessage_t_choice_msSUPLRESPONSE_get;
*swig_msSUPLRESPONSE_set = *SUPL::XSc::UlpMessage_t_choice_msSUPLRESPONSE_set;
*swig_msSUPLPOSINIT_get = *SUPL::XSc::UlpMessage_t_choice_msSUPLPOSINIT_get;
*swig_msSUPLPOSINIT_set = *SUPL::XSc::UlpMessage_t_choice_msSUPLPOSINIT_set;
*swig_msSUPLPOS_get = *SUPL::XSc::UlpMessage_t_choice_msSUPLPOS_get;
*swig_msSUPLPOS_set = *SUPL::XSc::UlpMessage_t_choice_msSUPLPOS_set;
*swig_msSUPLEND_get = *SUPL::XSc::UlpMessage_t_choice_msSUPLEND_get;
*swig_msSUPLEND_set = *SUPL::XSc::UlpMessage_t_choice_msSUPLEND_set;
*swig_msSUPLAUTHREQ_get = *SUPL::XSc::UlpMessage_t_choice_msSUPLAUTHREQ_get;
*swig_msSUPLAUTHREQ_set = *SUPL::XSc::UlpMessage_t_choice_msSUPLAUTHREQ_set;
*swig_msSUPLAUTHRESP_get = *SUPL::XSc::UlpMessage_t_choice_msSUPLAUTHRESP_get;
*swig_msSUPLAUTHRESP_set = *SUPL::XSc::UlpMessage_t_choice_msSUPLAUTHRESP_set;
sub new {
    my $pkg = shift;
    my $self = SUPL::XSc::new_UlpMessage_t_choice(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SUPL::XSc::delete_UlpMessage_t_choice($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- CONSTANT STUBS -------

package SUPL::XS;

sub setcap_pos_tech_agpsSETassisted () { $SUPL::XSc::setcap_pos_tech_agpsSETassisted }
sub setcap_pos_tech_agpsSETBased () { $SUPL::XSc::setcap_pos_tech_agpsSETBased }
sub setcap_pos_tech_autonomousGPS () { $SUPL::XSc::setcap_pos_tech_autonomousGPS }
sub setcap_pos_tech_aFLT () { $SUPL::XSc::setcap_pos_tech_aFLT }
sub setcap_pos_tech_eCID () { $SUPL::XSc::setcap_pos_tech_eCID }
sub setcap_pos_tech_eOTD () { $SUPL::XSc::setcap_pos_tech_eOTD }
sub setcap_pos_tech_oTDOA () { $SUPL::XSc::setcap_pos_tech_oTDOA }
sub setcap_pos_proto_tia801 () { $SUPL::XSc::setcap_pos_proto_tia801 }
sub setcap_pos_proto_rrlp () { $SUPL::XSc::setcap_pos_proto_rrlp }
sub setcap_pos_proto_rrc () { $SUPL::XSc::setcap_pos_proto_rrc }
sub reqassistdata_almanacRequested () { $SUPL::XSc::reqassistdata_almanacRequested }
sub reqassistdata_utcModelRequested () { $SUPL::XSc::reqassistdata_utcModelRequested }
sub reqassistdata_ionosphericModelRequested () { $SUPL::XSc::reqassistdata_ionosphericModelRequested }
sub reqassistdata_dgpsCorrectionsRequested () { $SUPL::XSc::reqassistdata_dgpsCorrectionsRequested }
sub reqassistdata_referenceLocationRequested () { $SUPL::XSc::reqassistdata_referenceLocationRequested }
sub reqassistdata_referenceTimeRequested () { $SUPL::XSc::reqassistdata_referenceTimeRequested }
sub reqassistdata_acquisitionAssistanceRequested () { $SUPL::XSc::reqassistdata_acquisitionAssistanceRequested }
sub reqassistdata_realTimeIntegrityRequested () { $SUPL::XSc::reqassistdata_realTimeIntegrityRequested }
sub UlpMessage_PR_NOTHING () { $SUPL::XSc::UlpMessage_PR_NOTHING }
sub UlpMessage_PR_msSUPLINIT () { $SUPL::XSc::UlpMessage_PR_msSUPLINIT }
sub UlpMessage_PR_msSUPLSTART () { $SUPL::XSc::UlpMessage_PR_msSUPLSTART }
sub UlpMessage_PR_msSUPLRESPONSE () { $SUPL::XSc::UlpMessage_PR_msSUPLRESPONSE }
sub UlpMessage_PR_msSUPLPOSINIT () { $SUPL::XSc::UlpMessage_PR_msSUPLPOSINIT }
sub UlpMessage_PR_msSUPLPOS () { $SUPL::XSc::UlpMessage_PR_msSUPLPOS }
sub UlpMessage_PR_msSUPLEND () { $SUPL::XSc::UlpMessage_PR_msSUPLEND }
sub UlpMessage_PR_msSUPLAUTHREQ () { $SUPL::XSc::UlpMessage_PR_msSUPLAUTHREQ }
sub UlpMessage_PR_msSUPLAUTHRESP () { $SUPL::XSc::UlpMessage_PR_msSUPLAUTHRESP }
sub PrefMethod_agpsSETassistedPreferred () { $SUPL::XSc::PrefMethod_agpsSETassistedPreferred }
sub PrefMethod_agpsSETBasedPreferred () { $SUPL::XSc::PrefMethod_agpsSETBasedPreferred }
sub PrefMethod_noPreference () { $SUPL::XSc::PrefMethod_noPreference }

# ------- VARIABLE STUBS --------

package SUPL::XS;

*asn_DEF_SUPLAUTHREQ = *SUPL::XSc::asn_DEF_SUPLAUTHREQ;
*asn_DEF_SUPLAUTHRESP = *SUPL::XSc::asn_DEF_SUPLAUTHRESP;
*asn_DEF_SUPLEND = *SUPL::XSc::asn_DEF_SUPLEND;
*asn_DEF_SUPLINIT = *SUPL::XSc::asn_DEF_SUPLINIT;
*asn_DEF_SUPLPOS = *SUPL::XSc::asn_DEF_SUPLPOS;
*asn_DEF_SUPLPOSINIT = *SUPL::XSc::asn_DEF_SUPLPOSINIT;
*asn_DEF_SUPLRESPONSE = *SUPL::XSc::asn_DEF_SUPLRESPONSE;
*asn_DEF_SUPLSTART = *SUPL::XSc::asn_DEF_SUPLSTART;
*asn_DEF_ULP_PDU = *SUPL::XSc::asn_DEF_ULP_PDU;
*asn_DEF_UlpMessage = *SUPL::XSc::asn_DEF_UlpMessage;
1;
