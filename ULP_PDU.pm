# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.6
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package ULP_PDU;
use base qw(Exporter);
use base qw(DynaLoader);
package ULP_PDUc;
bootstrap ULP_PDU;
package ULP_PDU;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package ULP_PDU;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package ULP_PDU;

*encode_ulp_pdu = *ULP_PDUc::encode_ulp_pdu;
*decode_ulp_pdu = *ULP_PDUc::decode_ulp_pdu;
*ulp_pdu_to_xml = *ULP_PDUc::ulp_pdu_to_xml;

############# Class : ULP_PDU::SUPLAUTHREQ_t ##############

package ULP_PDU::SUPLAUTHREQ_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ULP_PDU );
%OWNER = ();
%ITERATORS = ();
*swig_sETNonce_get = *ULP_PDUc::SUPLAUTHREQ_t_sETNonce_get;
*swig_sETNonce_set = *ULP_PDUc::SUPLAUTHREQ_t_sETNonce_set;
*swig_keyIdentity2_get = *ULP_PDUc::SUPLAUTHREQ_t_keyIdentity2_get;
*swig_keyIdentity2_set = *ULP_PDUc::SUPLAUTHREQ_t_keyIdentity2_set;
*swig__asn_ctx_get = *ULP_PDUc::SUPLAUTHREQ_t__asn_ctx_get;
*swig__asn_ctx_set = *ULP_PDUc::SUPLAUTHREQ_t__asn_ctx_set;
sub new {
    my $pkg = shift;
    my $self = ULP_PDUc::new_SUPLAUTHREQ_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ULP_PDUc::delete_SUPLAUTHREQ_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ULP_PDU::SUPLAUTHRESP_t ##############

package ULP_PDU::SUPLAUTHRESP_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ULP_PDU );
%OWNER = ();
%ITERATORS = ();
*swig_sPCAuthKey_get = *ULP_PDUc::SUPLAUTHRESP_t_sPCAuthKey_get;
*swig_sPCAuthKey_set = *ULP_PDUc::SUPLAUTHRESP_t_sPCAuthKey_set;
*swig_keyIdentity3_get = *ULP_PDUc::SUPLAUTHRESP_t_keyIdentity3_get;
*swig_keyIdentity3_set = *ULP_PDUc::SUPLAUTHRESP_t_keyIdentity3_set;
*swig_statusCode_get = *ULP_PDUc::SUPLAUTHRESP_t_statusCode_get;
*swig_statusCode_set = *ULP_PDUc::SUPLAUTHRESP_t_statusCode_set;
*swig__asn_ctx_get = *ULP_PDUc::SUPLAUTHRESP_t__asn_ctx_get;
*swig__asn_ctx_set = *ULP_PDUc::SUPLAUTHRESP_t__asn_ctx_set;
sub new {
    my $pkg = shift;
    my $self = ULP_PDUc::new_SUPLAUTHRESP_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ULP_PDUc::delete_SUPLAUTHRESP_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ULP_PDU::SUPLEND_t ##############

package ULP_PDU::SUPLEND_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ULP_PDU );
%OWNER = ();
%ITERATORS = ();
*swig_position_get = *ULP_PDUc::SUPLEND_t_position_get;
*swig_position_set = *ULP_PDUc::SUPLEND_t_position_set;
*swig_statusCode_get = *ULP_PDUc::SUPLEND_t_statusCode_get;
*swig_statusCode_set = *ULP_PDUc::SUPLEND_t_statusCode_set;
*swig_ver_get = *ULP_PDUc::SUPLEND_t_ver_get;
*swig_ver_set = *ULP_PDUc::SUPLEND_t_ver_set;
*swig__asn_ctx_get = *ULP_PDUc::SUPLEND_t__asn_ctx_get;
*swig__asn_ctx_set = *ULP_PDUc::SUPLEND_t__asn_ctx_set;
sub new {
    my $pkg = shift;
    my $self = ULP_PDUc::new_SUPLEND_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ULP_PDUc::delete_SUPLEND_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ULP_PDU::SUPLINIT_t ##############

package ULP_PDU::SUPLINIT_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ULP_PDU );
%OWNER = ();
%ITERATORS = ();
*swig_posMethod_get = *ULP_PDUc::SUPLINIT_t_posMethod_get;
*swig_posMethod_set = *ULP_PDUc::SUPLINIT_t_posMethod_set;
*swig_notification_get = *ULP_PDUc::SUPLINIT_t_notification_get;
*swig_notification_set = *ULP_PDUc::SUPLINIT_t_notification_set;
*swig_sLPAddress_get = *ULP_PDUc::SUPLINIT_t_sLPAddress_get;
*swig_sLPAddress_set = *ULP_PDUc::SUPLINIT_t_sLPAddress_set;
*swig_qoP_get = *ULP_PDUc::SUPLINIT_t_qoP_get;
*swig_qoP_set = *ULP_PDUc::SUPLINIT_t_qoP_set;
*swig_sLPMode_get = *ULP_PDUc::SUPLINIT_t_sLPMode_get;
*swig_sLPMode_set = *ULP_PDUc::SUPLINIT_t_sLPMode_set;
*swig_mAC_get = *ULP_PDUc::SUPLINIT_t_mAC_get;
*swig_mAC_set = *ULP_PDUc::SUPLINIT_t_mAC_set;
*swig_keyIdentity_get = *ULP_PDUc::SUPLINIT_t_keyIdentity_get;
*swig_keyIdentity_set = *ULP_PDUc::SUPLINIT_t_keyIdentity_set;
*swig__asn_ctx_get = *ULP_PDUc::SUPLINIT_t__asn_ctx_get;
*swig__asn_ctx_set = *ULP_PDUc::SUPLINIT_t__asn_ctx_set;
sub new {
    my $pkg = shift;
    my $self = ULP_PDUc::new_SUPLINIT_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ULP_PDUc::delete_SUPLINIT_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ULP_PDU::SUPLPOS_t ##############

package ULP_PDU::SUPLPOS_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ULP_PDU );
%OWNER = ();
%ITERATORS = ();
*swig_posPayLoad_get = *ULP_PDUc::SUPLPOS_t_posPayLoad_get;
*swig_posPayLoad_set = *ULP_PDUc::SUPLPOS_t_posPayLoad_set;
*swig_velocity_get = *ULP_PDUc::SUPLPOS_t_velocity_get;
*swig_velocity_set = *ULP_PDUc::SUPLPOS_t_velocity_set;
*swig__asn_ctx_get = *ULP_PDUc::SUPLPOS_t__asn_ctx_get;
*swig__asn_ctx_set = *ULP_PDUc::SUPLPOS_t__asn_ctx_set;
sub new {
    my $pkg = shift;
    my $self = ULP_PDUc::new_SUPLPOS_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ULP_PDUc::delete_SUPLPOS_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ULP_PDU::SUPLPOSINIT_t ##############

package ULP_PDU::SUPLPOSINIT_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ULP_PDU );
%OWNER = ();
%ITERATORS = ();
*swig_sETCapabilities_get = *ULP_PDUc::SUPLPOSINIT_t_sETCapabilities_get;
*swig_sETCapabilities_set = *ULP_PDUc::SUPLPOSINIT_t_sETCapabilities_set;
*swig_requestedAssistData_get = *ULP_PDUc::SUPLPOSINIT_t_requestedAssistData_get;
*swig_requestedAssistData_set = *ULP_PDUc::SUPLPOSINIT_t_requestedAssistData_set;
*swig_locationId_get = *ULP_PDUc::SUPLPOSINIT_t_locationId_get;
*swig_locationId_set = *ULP_PDUc::SUPLPOSINIT_t_locationId_set;
*swig_position_get = *ULP_PDUc::SUPLPOSINIT_t_position_get;
*swig_position_set = *ULP_PDUc::SUPLPOSINIT_t_position_set;
*swig_sUPLPOS_get = *ULP_PDUc::SUPLPOSINIT_t_sUPLPOS_get;
*swig_sUPLPOS_set = *ULP_PDUc::SUPLPOSINIT_t_sUPLPOS_set;
*swig_ver_get = *ULP_PDUc::SUPLPOSINIT_t_ver_get;
*swig_ver_set = *ULP_PDUc::SUPLPOSINIT_t_ver_set;
*swig__asn_ctx_get = *ULP_PDUc::SUPLPOSINIT_t__asn_ctx_get;
*swig__asn_ctx_set = *ULP_PDUc::SUPLPOSINIT_t__asn_ctx_set;
sub new {
    my $pkg = shift;
    my $self = ULP_PDUc::new_SUPLPOSINIT_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ULP_PDUc::delete_SUPLPOSINIT_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ULP_PDU::SUPLRESPONSE_t ##############

package ULP_PDU::SUPLRESPONSE_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ULP_PDU );
%OWNER = ();
%ITERATORS = ();
*swig_posMethod_get = *ULP_PDUc::SUPLRESPONSE_t_posMethod_get;
*swig_posMethod_set = *ULP_PDUc::SUPLRESPONSE_t_posMethod_set;
*swig_sLPAddress_get = *ULP_PDUc::SUPLRESPONSE_t_sLPAddress_get;
*swig_sLPAddress_set = *ULP_PDUc::SUPLRESPONSE_t_sLPAddress_set;
*swig_sETAuthKey_get = *ULP_PDUc::SUPLRESPONSE_t_sETAuthKey_get;
*swig_sETAuthKey_set = *ULP_PDUc::SUPLRESPONSE_t_sETAuthKey_set;
*swig_keyIdentity4_get = *ULP_PDUc::SUPLRESPONSE_t_keyIdentity4_get;
*swig_keyIdentity4_set = *ULP_PDUc::SUPLRESPONSE_t_keyIdentity4_set;
*swig__asn_ctx_get = *ULP_PDUc::SUPLRESPONSE_t__asn_ctx_get;
*swig__asn_ctx_set = *ULP_PDUc::SUPLRESPONSE_t__asn_ctx_set;
sub new {
    my $pkg = shift;
    my $self = ULP_PDUc::new_SUPLRESPONSE_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ULP_PDUc::delete_SUPLRESPONSE_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ULP_PDU::SUPLSTART_t ##############

package ULP_PDU::SUPLSTART_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ULP_PDU );
%OWNER = ();
%ITERATORS = ();
*swig_sETCapabilities_get = *ULP_PDUc::SUPLSTART_t_sETCapabilities_get;
*swig_sETCapabilities_set = *ULP_PDUc::SUPLSTART_t_sETCapabilities_set;
*swig_locationId_get = *ULP_PDUc::SUPLSTART_t_locationId_get;
*swig_locationId_set = *ULP_PDUc::SUPLSTART_t_locationId_set;
*swig_qoP_get = *ULP_PDUc::SUPLSTART_t_qoP_get;
*swig_qoP_set = *ULP_PDUc::SUPLSTART_t_qoP_set;
*swig__asn_ctx_get = *ULP_PDUc::SUPLSTART_t__asn_ctx_get;
*swig__asn_ctx_set = *ULP_PDUc::SUPLSTART_t__asn_ctx_set;
sub new {
    my $pkg = shift;
    my $self = ULP_PDUc::new_SUPLSTART_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ULP_PDUc::delete_SUPLSTART_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ULP_PDU::ULP_PDU_t ##############

package ULP_PDU::ULP_PDU_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ULP_PDU );
%OWNER = ();
%ITERATORS = ();
*swig_length_get = *ULP_PDUc::ULP_PDU_t_length_get;
*swig_length_set = *ULP_PDUc::ULP_PDU_t_length_set;
*swig_version_get = *ULP_PDUc::ULP_PDU_t_version_get;
*swig_version_set = *ULP_PDUc::ULP_PDU_t_version_set;
*swig_sessionID_get = *ULP_PDUc::ULP_PDU_t_sessionID_get;
*swig_sessionID_set = *ULP_PDUc::ULP_PDU_t_sessionID_set;
*swig_message_get = *ULP_PDUc::ULP_PDU_t_message_get;
*swig_message_set = *ULP_PDUc::ULP_PDU_t_message_set;
*swig__asn_ctx_get = *ULP_PDUc::ULP_PDU_t__asn_ctx_get;
*swig__asn_ctx_set = *ULP_PDUc::ULP_PDU_t__asn_ctx_set;
sub new {
    my $pkg = shift;
    my $self = ULP_PDUc::new_ULP_PDU_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ULP_PDUc::delete_ULP_PDU_t($self);
        delete $OWNER{$self};
    }
}

*set_version = *ULP_PDUc::ULP_PDU_t_set_version;
*setSetSessionId_to_imsi = *ULP_PDUc::ULP_PDU_t_setSetSessionId_to_imsi;
*setSetSessionId_to_msisdn = *ULP_PDUc::ULP_PDU_t_setSetSessionId_to_msisdn;
*copy_SlpSessionId = *ULP_PDUc::ULP_PDU_t_copy_SlpSessionId;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ULP_PDU::UlpMessage_t ##############

package ULP_PDU::UlpMessage_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ULP_PDU );
%OWNER = ();
%ITERATORS = ();
*swig_present_get = *ULP_PDUc::UlpMessage_t_present_get;
*swig_present_set = *ULP_PDUc::UlpMessage_t_present_set;
*swig__asn_ctx_get = *ULP_PDUc::UlpMessage_t__asn_ctx_get;
*swig__asn_ctx_set = *ULP_PDUc::UlpMessage_t__asn_ctx_set;
*swig_choice_get = *ULP_PDUc::UlpMessage_t_choice_get;
*swig_choice_set = *ULP_PDUc::UlpMessage_t_choice_set;
sub new {
    my $pkg = shift;
    my $self = ULP_PDUc::new_UlpMessage_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ULP_PDUc::delete_UlpMessage_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ULP_PDU::UlpMessage_t_choice ##############

package ULP_PDU::UlpMessage_t_choice;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ULP_PDU );
%OWNER = ();
%ITERATORS = ();
*swig_msSUPLINIT_get = *ULP_PDUc::UlpMessage_t_choice_msSUPLINIT_get;
*swig_msSUPLINIT_set = *ULP_PDUc::UlpMessage_t_choice_msSUPLINIT_set;
*swig_msSUPLSTART_get = *ULP_PDUc::UlpMessage_t_choice_msSUPLSTART_get;
*swig_msSUPLSTART_set = *ULP_PDUc::UlpMessage_t_choice_msSUPLSTART_set;
*swig_msSUPLRESPONSE_get = *ULP_PDUc::UlpMessage_t_choice_msSUPLRESPONSE_get;
*swig_msSUPLRESPONSE_set = *ULP_PDUc::UlpMessage_t_choice_msSUPLRESPONSE_set;
*swig_msSUPLPOSINIT_get = *ULP_PDUc::UlpMessage_t_choice_msSUPLPOSINIT_get;
*swig_msSUPLPOSINIT_set = *ULP_PDUc::UlpMessage_t_choice_msSUPLPOSINIT_set;
*swig_msSUPLPOS_get = *ULP_PDUc::UlpMessage_t_choice_msSUPLPOS_get;
*swig_msSUPLPOS_set = *ULP_PDUc::UlpMessage_t_choice_msSUPLPOS_set;
*swig_msSUPLEND_get = *ULP_PDUc::UlpMessage_t_choice_msSUPLEND_get;
*swig_msSUPLEND_set = *ULP_PDUc::UlpMessage_t_choice_msSUPLEND_set;
*swig_msSUPLAUTHREQ_get = *ULP_PDUc::UlpMessage_t_choice_msSUPLAUTHREQ_get;
*swig_msSUPLAUTHREQ_set = *ULP_PDUc::UlpMessage_t_choice_msSUPLAUTHREQ_set;
*swig_msSUPLAUTHRESP_get = *ULP_PDUc::UlpMessage_t_choice_msSUPLAUTHRESP_get;
*swig_msSUPLAUTHRESP_set = *ULP_PDUc::UlpMessage_t_choice_msSUPLAUTHRESP_set;
sub new {
    my $pkg = shift;
    my $self = ULP_PDUc::new_UlpMessage_t_choice(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ULP_PDUc::delete_UlpMessage_t_choice($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package ULP_PDU;

*asn_DEF_SUPLAUTHREQ = *ULP_PDUc::asn_DEF_SUPLAUTHREQ;
*asn_DEF_SUPLAUTHRESP = *ULP_PDUc::asn_DEF_SUPLAUTHRESP;
*asn_DEF_SUPLEND = *ULP_PDUc::asn_DEF_SUPLEND;
*asn_DEF_SUPLINIT = *ULP_PDUc::asn_DEF_SUPLINIT;
*asn_DEF_SUPLPOS = *ULP_PDUc::asn_DEF_SUPLPOS;
*asn_DEF_SUPLPOSINIT = *ULP_PDUc::asn_DEF_SUPLPOSINIT;
*asn_DEF_SUPLRESPONSE = *ULP_PDUc::asn_DEF_SUPLRESPONSE;
*asn_DEF_SUPLSTART = *ULP_PDUc::asn_DEF_SUPLSTART;
*asn_DEF_ULP_PDU = *ULP_PDUc::asn_DEF_ULP_PDU;
*UlpMessage_PR_NOTHING = *ULP_PDUc::UlpMessage_PR_NOTHING;
*UlpMessage_PR_msSUPLINIT = *ULP_PDUc::UlpMessage_PR_msSUPLINIT;
*UlpMessage_PR_msSUPLSTART = *ULP_PDUc::UlpMessage_PR_msSUPLSTART;
*UlpMessage_PR_msSUPLRESPONSE = *ULP_PDUc::UlpMessage_PR_msSUPLRESPONSE;
*UlpMessage_PR_msSUPLPOSINIT = *ULP_PDUc::UlpMessage_PR_msSUPLPOSINIT;
*UlpMessage_PR_msSUPLPOS = *ULP_PDUc::UlpMessage_PR_msSUPLPOS;
*UlpMessage_PR_msSUPLEND = *ULP_PDUc::UlpMessage_PR_msSUPLEND;
*UlpMessage_PR_msSUPLAUTHREQ = *ULP_PDUc::UlpMessage_PR_msSUPLAUTHREQ;
*UlpMessage_PR_msSUPLAUTHRESP = *ULP_PDUc::UlpMessage_PR_msSUPLAUTHRESP;
*asn_DEF_UlpMessage = *ULP_PDUc::asn_DEF_UlpMessage;
1;
